use rand::random;
use serde::{Deserialize, Serialize};
use std::collections::{BTreeMap, HashMap};
use std::fs;
use thiserror::Error;

const PROTO_HEADER: &str = r#"/*
 * This proto file was automatically generated by Swagger to Proto converter.
 * Do not edit manually.
 */

syntax = "proto3";

import "google/protobuf/empty.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";

"#;

#[derive(Error, Debug)]
pub enum ConverterError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),
    #[error("JSON parse error: {0}")]
    JsonParse(#[from] serde_json::Error),
    #[error("Unsupported schema type: {0}")]
    UnsupportedSchemaType(String),
    #[error("Missing reference: {0}")]
    MissingReference(String),
    #[error("Invalid array definition")]
    InvalidArrayDefinition,
    #[error("Circular reference detected: {0}")]
    CircularReference(String),
    #[error("Duplicate message name: {0}")]
    DuplicateMessageName(String),
    #[error("Invalid parameter location: {0}")]
    InvalidParameterLocation(String),
    #[error("Unsupported HTTP method: {0}")]
    UnsupportedHttpMethod(String),
}

#[derive(Debug, Deserialize, Serialize, Clone)]
#[serde(untagged)]
enum SchemaRef {
    Ref {
        #[serde(rename = "$ref")]
        ref_path: String,
    },
    Inline(Box<Schema>),
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Schema {
    #[serde(rename = "type")]
    type_: Option<String>,
    format: Option<String>,
    description: Option<String>,
    items: Option<Box<SchemaRef>>,
    properties: Option<HashMap<String, Schema>>,
    additional_properties: Option<Box<SchemaRef>>,
    required: Option<Vec<String>>,
    #[serde(rename = "enum")]
    enum_values: Option<Vec<serde_json::Value>>,
    #[serde(rename = "$ref")]
    ref_path: Option<String>,
    one_of: Option<Vec<SchemaRef>>,
    all_of: Option<Vec<SchemaRef>>,
    any_of: Option<Vec<SchemaRef>>,
    nullable: Option<bool>,
    default: Option<serde_json::Value>,
    example: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize, Serialize)]
struct SwaggerDoc {
    swagger: Option<String>,
    openapi: Option<String>,
    info: Info,
    paths: HashMap<String, PathItem>,
    definitions: Option<HashMap<String, Schema>>,
    components: Option<Components>,
    tags: Option<Vec<Tag>>,
}

#[derive(Debug, Deserialize, Serialize)]
struct Info {
    title: String,
    description: Option<String>,
    version: String,
    contact: Option<Contact>,
    license: Option<License>,
}

#[derive(Debug, Deserialize, Serialize)]
struct Contact {
    name: Option<String>,
    url: Option<String>,
    email: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct License {
    name: String,
    url: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct Tag {
    name: String,
    description: Option<String>,
}

#[derive(Debug, Deserialize, Serialize)]
struct Components {
    schemas: Option<HashMap<String, Schema>>,
    responses: Option<HashMap<String, Response>>,
    parameters: Option<HashMap<String, Parameter>>,
    examples: Option<HashMap<String, Example>>,
    request_bodies: Option<HashMap<String, RequestBody>>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct PathItem {
    get: Option<Operation>,
    post: Option<Operation>,
    put: Option<Operation>,
    delete: Option<Operation>,
    patch: Option<Operation>,
    head: Option<Operation>,
    options: Option<Operation>,
    trace: Option<Operation>,
    parameters: Option<Vec<Parameter>>,
    #[serde(rename = "$ref")]
    ref_path: Option<String>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Operation {
    tags: Option<Vec<String>>,
    summary: Option<String>,
    description: Option<String>,
    operation_id: Option<String>,
    parameters: Option<Vec<Parameter>>,
    request_body: Option<RequestBody>,
    responses: HashMap<String, Response>,
    deprecated: Option<bool>,
    security: Option<Vec<HashMap<String, Vec<String>>>>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Parameter {
    name: String,
    #[serde(rename = "in")]
    in_: String,
    description: Option<String>,
    required: Option<bool>,
    schema: Option<SchemaRef>,
    #[serde(rename = "type")]
    type_: Option<String>,
    format: Option<String>,
    default: Option<serde_json::Value>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct RequestBody {
    description: Option<String>,
    content: HashMap<String, MediaType>,
    required: Option<bool>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct MediaType {
    schema: Option<SchemaRef>,
    example: Option<serde_json::Value>,
    examples: Option<HashMap<String, Example>>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Example {
    summary: Option<String>,
    description: Option<String>,
    value: Option<serde_json::Value>,
    external_value: Option<String>,
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Response {
    description: String,
    content: Option<HashMap<String, MediaType>>,
    #[serde(rename = "$ref")]
    ref_path: Option<String>,
    headers: Option<HashMap<String, Header>>,
    // Для Swagger 2.0 совместимости:
    schema: Option<SchemaRef>, // Добавьте это поле
}

#[derive(Debug, Deserialize, Serialize, Clone)]
struct Header {
    description: Option<String>,
    #[serde(rename = "type")]
    type_: String,
    format: Option<String>,
}

struct ProtoConverter {
    messages: HashMap<String, String>,
    generated_messages: HashMap<String, usize>,
    current_refs: Vec<String>,
}

impl ProtoConverter {
    pub fn new() -> Self {
        Self {
            messages: HashMap::new(),
            generated_messages: HashMap::new(),
            current_refs: Vec::new(),
        }
    }

    pub fn convert(&mut self, input_path: &str, output_path: &str) -> Result<(), ConverterError> {
        let content = fs::read_to_string(input_path)?;
        let spec: SwaggerDoc = serde_json::from_str(&content)?;
        let proto_content = self.generate_proto(&spec)?;
        fs::write(output_path, proto_content)?;

        Ok(())
    }

    fn generate_proto(&mut self, spec: &SwaggerDoc) -> Result<String, ConverterError> {
        let mut proto = String::new();
        proto.push_str(PROTO_HEADER);

        // Add package and imports
        proto.push_str(&self.generate_header_info(&spec.info));
        proto.push_str("\n");

        // Generate all schemas
        if let Some(definitions) = &spec.definitions {
            self.generate_schemas(&mut proto, definitions, None)?;
        }

        if let Some(components) = &spec.components {
            if let Some(schemas) = &components.schemas {
                self.generate_schemas(&mut proto, schemas, Some(components))?;
            }
        }

        // Generate services
        self.generate_services(&mut proto, &spec.paths, spec)?;

        Ok(proto)
    }

    fn generate_header_info(&self, info: &Info) -> String {
        let mut header = String::new();
        header.push_str(&format!("// Title: {}\n", info.title));
        header.push_str(&format!("// Version: {}\n", info.version));

        if let Some(description) = &info.description {
            header.push_str("/*\n");
            for line in description.lines() {
                header.push_str(&format!(" * {}\n", line.trim()));
            }
            header.push_str(" */\n");
        }

        header.push_str("\n");
        header.push_str("package api;\n\n");

        header
    }

    fn generate_schemas(
        &mut self,
        proto: &mut String,
        schemas: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<(), ConverterError> {
        for (name, schema) in schemas {
            if self.generated_messages.contains_key(name) {
                continue;
            }

            let message = self.convert_schema_to_message(name, schema, schemas, components)?;
            proto.push_str(&message);
            self.generated_messages.insert(name.clone(), 1);
        }

        Ok(())
    }

    fn convert_schema_to_message(
        &mut self,
        name: &str,
        schema: &Schema,
        definitions: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<String, ConverterError> {
        // Check for circular references
        if self.current_refs.contains(&name.to_string()) {
            return Err(ConverterError::CircularReference(name.to_string()));
        }
        self.current_refs.push(name.to_string());

        let mut message = String::new();

        // Add description as comment
        if let Some(description) = &schema.description {
            message.push_str(&format!("/* {} */\n", description.trim()));
        }

        message.push_str(&format!("message {} {{\n", name));

        // Handle oneOf, allOf, anyOf
        if let Some(one_of) = &schema.one_of {
            message.push_str("  oneof {\n");
            for (i, item) in one_of.iter().enumerate() {
                let type_name = self.schema_ref_to_type(item, definitions, components)?;
                message.push_str(&format!(
                    "    {} variant_{} = {};\n",
                    type_name,
                    i + 1,
                    i + 1
                ));
            }
            message.push_str("  }\n");
        } else if let Some(all_of) = &schema.all_of {
            let mut field_number = 1;
            for item in all_of {
                let resolved = self.resolve_schema_ref(item, definitions, components)?;
                if let Some(properties) = &resolved.properties {
                    for (prop_name, prop_schema) in properties {
                        let type_name =
                            self.schema_to_type(prop_schema, definitions, components)?;
                        message.push_str(&format!(
                            "  {} {} = {};\n",
                            type_name, prop_name, field_number
                        ));
                        field_number += 1;
                    }
                }
            }
        } else if let Some(any_of) = &schema.any_of {
            message.push_str("  oneof {\n");
            for (i, item) in any_of.iter().enumerate() {
                let type_name = self.schema_ref_to_type(item, definitions, components)?;
                message.push_str(&format!(
                    "    {} variant_{} = {};\n",
                    type_name,
                    i + 1,
                    i + 1
                ));
            }
            message.push_str("  }\n");
        } else if let Some(properties) = &schema.properties {
            let mut field_number = 1;
            for (prop_name, prop_schema) in properties {
                // Add property description
                if let Some(description) = &prop_schema.description {
                    message.push_str(&format!("  /* {} */\n", description.trim()));
                }

                let type_name = self.schema_to_type(prop_schema, definitions, components)?;

                // Check if required
                let is_required = schema
                    .required
                    .as_ref()
                    .map(|r| r.contains(prop_name))
                    .unwrap_or(false);

                let field_rule = if is_required { "" } else { "optional " };

                // Add field
                message.push_str(&format!(
                    "  {}{} {} = {};\n",
                    field_rule,
                    type_name,
                    self.sanitize_field_name(prop_name),
                    field_number
                ));

                field_number += 1;
            }
        } else if schema.additional_properties.is_some() {
            let additional_props = schema.additional_properties.as_ref().unwrap();
            let value_type = self.schema_ref_to_type(additional_props, definitions, components)?;
            message.push_str(&format!("  map<string, {}> properties = 1;\n", value_type));
        }

        message.push_str("}\n\n");
        self.current_refs.pop();

        Ok(message)
    }

    fn schema_to_type(
        &mut self,
        schema: &Schema,
        definitions: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<String, ConverterError> {
        if let Some(ref_path) = &schema.ref_path {
            return Ok(self.resolve_ref_name(ref_path));
        }

        match schema.type_.as_deref() {
            Some("integer") => match schema.format.as_deref() {
                Some("int64") => Ok("int64".to_string()),
                Some("int32") => Ok("int32".to_string()),
                _ => Ok("int64".to_string()),
            },
            Some("number") => match schema.format.as_deref() {
                Some("double") => Ok("double".to_string()),
                Some("float") => Ok("float".to_string()),
                _ => Ok("double".to_string()),
            },
            Some("boolean") => Ok("bool".to_string()),
            Some("string") => match schema.format.as_deref() {
                Some("date") => Ok("google.protobuf.Timestamp".to_string()),
                Some("date-time") => Ok("google.protobuf.Timestamp".to_string()),
                Some("byte") => Ok("bytes".to_string()),
                Some("binary") => Ok("bytes".to_string()),
                _ => Ok("string".to_string()),
            },
            Some("array") => {
                let items = schema
                    .items
                    .as_ref()
                    .ok_or(ConverterError::InvalidArrayDefinition)?;
                let item_type = self.schema_ref_to_type(items, definitions, components)?;
                Ok(format!("repeated {}", item_type))
            }
            Some("object") => {
                if schema.properties.is_some() || schema.all_of.is_some() {
                    // Generate nested message for complex objects
                    let temp_name = format!("NestedObject_{}", random::<u32>());
                    let message = self.convert_schema_to_message(
                        &temp_name,
                        schema,
                        definitions,
                        components,
                    )?;
                    self.messages.insert(temp_name.clone(), message);
                    Ok(temp_name)
                } else if let Some(additional_props) = &schema.additional_properties {
                    let value_type =
                        self.schema_ref_to_type(additional_props, definitions, components)?;
                    Ok(format!("map<string, {}>", value_type))
                } else {
                    Ok("google.protobuf.Struct".to_string())
                }
            }
            None if schema.enum_values.is_some() => {
                let temp_name = format!("Enum_{}", random::<u32>());
                let mut enum_def = format!("enum {} {{\n", temp_name);
                for (i, value) in schema.enum_values.as_ref().unwrap().iter().enumerate() {
                    let variant_name = match value {
                        serde_json::Value::String(s) => s
                            .to_uppercase()
                            .replace(|c: char| !c.is_alphanumeric(), "_"),
                        _ => format!("VALUE_{}", i + 1),
                    };
                    enum_def.push_str(&format!("  {} = {};\n", variant_name, i + 1));
                }
                enum_def.push_str("}\n\n");
                self.messages.insert(temp_name.clone(), enum_def);
                Ok(temp_name)
            }
            None => Err(ConverterError::UnsupportedSchemaType("unknown".to_string())),
            Some(t) => Err(ConverterError::UnsupportedSchemaType(t.to_string())),
        }
    }

    fn schema_ref_to_type(
        &mut self,
        schema_ref: &SchemaRef,
        definitions: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<String, ConverterError> {
        match schema_ref {
            SchemaRef::Ref { ref_path } => Ok(self.resolve_ref_name(ref_path)),
            SchemaRef::Inline(schema) => self.schema_to_type(schema, definitions, components),
        }
    }

    fn resolve_ref_name(&self, ref_path: &str) -> String {
        ref_path
            .split('/')
            .last()
            .unwrap_or("UnknownRef")
            .to_string()
    }

    fn resolve_schema_ref(
        &self,
        schema_ref: &SchemaRef,
        definitions: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<Schema, ConverterError> {
        match schema_ref {
            SchemaRef::Ref { ref_path } => {
                let ref_name = ref_path
                    .split('/')
                    .last()
                    .ok_or_else(|| ConverterError::MissingReference(ref_path.clone()))?;

                // Check definitions (Swagger 2.0)
                if let Some(schema) = definitions.get(ref_name) {
                    return Ok(schema.clone());
                }

                // Check components (OpenAPI 3.0)
                if let Some(components) = components {
                    if let Some(schemas) = &components.schemas {
                        if let Some(schema) = schemas.get(ref_name) {
                            return Ok(schema.clone());
                        }
                    }
                }

                Err(ConverterError::MissingReference(ref_path.clone()))
            }
            SchemaRef::Inline(schema) => Ok(*schema.clone()),
        }
    }

    fn generate_services<'a>(
        &mut self,
        proto: &mut String,
        paths: &'a HashMap<String, PathItem>,
        spec: &'a SwaggerDoc,
    ) -> Result<(), ConverterError> {
        let mut services: BTreeMap<String, Vec<(String, String, &'a Operation)>> = BTreeMap::new();

        // Явно указываем тип для definitions
        let definitions: &HashMap<String, Schema> =
            spec.definitions.as_ref().unwrap_or_else(|| {
                static EMPTY: once_cell::sync::Lazy<HashMap<String, Schema>> =
                    once_cell::sync::Lazy::new(|| HashMap::new());
                &EMPTY
            });

        let components = spec.components.as_ref();

        // Собираем операции
        for (path, item) in paths {
            self.collect_operations(&mut services, path, "GET", item.get.as_ref());
            self.collect_operations(&mut services, path, "POST", item.post.as_ref());
            self.collect_operations(&mut services, path, "PUT", item.put.as_ref());
            self.collect_operations(&mut services, path, "DELETE", item.delete.as_ref());
            self.collect_operations(&mut services, path, "PATCH", item.patch.as_ref());
        }

        // Обрабатываем DefaultService
        if let Some(default_ops) = services.remove("Default") {
            if !default_ops.is_empty() {
                self.generate_service_proto(
                    proto,
                    "Default",
                    &default_ops,
                    definitions,
                    components,
                )?;
            }
        }

        // Обрабатываем остальные сервисы
        for (tag, methods) in services {
            if methods.is_empty() {
                continue;
            }

            let service_name = self.to_pascal_case(&tag);
            self.generate_service_proto(proto, &service_name, &methods, definitions, components)?;
        }

        Ok(())
    }

    fn generate_request_message(
        &mut self,
        service_name: &str,
        method_name: &str,
        operation: &Operation,
        definitions: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<(String, Vec<String>), ConverterError> {
        let mut messages = Vec::new();
        let mut has_query = false;
        let mut has_body = false;
        let mut query_message_name = String::new();

        // Обработка параметров пути и запроса
        if let Some(parameters) = &operation.parameters {
            let query_params: Vec<_> = parameters
                .iter()
                .filter(|p| p.in_ == "query" || p.in_ == "path")
                .collect();

            if !query_params.is_empty() {
                has_query = true;
                query_message_name = format!("{}{}QueryParams", service_name, method_name);
                let message = self.generate_parameters_message(
                    &query_message_name,
                    query_params,
                    definitions,
                    components,
                )?;
                messages.push(message);
            }

            // Обработка body-параметров (Swagger 2.0)
            if let Some(body_param) = parameters.iter().find(|p| p.in_ == "body") {
                has_body = true;
                let body_message_name = format!("{}{}RequestBody", service_name, method_name);
                let mut fake_request_body = RequestBody {
                    description: body_param.description.clone(),
                    content: HashMap::new(),
                    required: body_param.required,
                };

                if let Some(schema_ref) = &body_param.schema {
                    let media_type = MediaType {
                        schema: Some(schema_ref.clone()),
                        example: None,
                        examples: None,
                    };
                    fake_request_body
                        .content
                        .insert("application/json".to_string(), media_type);
                }

                let message = self.generate_body_message(
                    &body_message_name,
                    &fake_request_body,
                    definitions,
                    components,
                )?;
                messages.push(message);
            }
        }

        // Обработка тела запроса (OpenAPI 3.0)
        if let Some(request_body) = &operation.request_body {
            has_body = true;
            let body_message_name = format!("{}{}RequestBody", service_name, method_name);
            let message = self.generate_body_message(
                &body_message_name,
                request_body,
                definitions,
                components,
            )?;
            messages.push(message);
        }

        // Определяем тип запроса
        let request_type = match (has_query, has_body) {
            (true, true) => {
                let combined_name = format!("{}{}Request", service_name, method_name);
                let combined_message = format!(
                    "message {} {{\n  {} params = 1;\n  {} body = 2;\n}}\n\n",
                    combined_name,
                    query_message_name,
                    format!("{}{}RequestBody", service_name, method_name)
                );
                messages.push(combined_message);
                combined_name
            }
            (true, false) => query_message_name,
            (false, true) => format!("{}{}RequestBody", service_name, method_name),
            (false, false) => "google.protobuf.Empty".to_string(),
        };

        Ok((request_type, messages))
    }

    fn generate_response_type(
        &mut self,
        operation: &Operation,
        definitions: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<String, ConverterError> {
        // Find first successful response (2xx)
        let success_response = operation
            .responses
            .iter()
            .find(|(code, _)| code.starts_with('2'))
            .map(|(_, r)| r);

        if let Some(response) = success_response {
            // OpenAPI 3.0 style - check content first
            if let Some(content) = &response.content {
                if let Some((_, media_type)) = content.iter().next() {
                    if let Some(schema_ref) = &media_type.schema {
                        return self.schema_ref_to_type(schema_ref, definitions, components);
                    }
                }
            }

            // Swagger 2.0 compatibility - check schema directly
            if let Some(schema_ref) = &response.schema {
                return self.schema_ref_to_type(schema_ref, definitions, components);
            }

            // Check for reference
            if let Some(ref_path) = &response.ref_path {
                return Ok(self.resolve_ref_name(ref_path));
            }
        }

        Ok("google.protobuf.Empty".to_string())
    }
    fn collect_operations<'a>(
        &self,
        services: &mut BTreeMap<String, Vec<(String, String, &'a Operation)>>,
        path: &str,
        method: &str,
        operation: Option<&'a Operation>,
    ) {
        if let Some(op) = operation {
            let default_tags = vec!["Default".to_string()];
            let tags = op.tags.as_ref().unwrap_or(&default_tags);

            for tag in tags {
                services.entry(tag.clone()).or_default().push((
                    path.to_string(),
                    method.to_string(),
                    op,
                ));
            }
        }
    }

    fn generate_method_name(&self, path: &str, http_method: &str, operation: &Operation) -> String {
        operation.operation_id.as_ref().map_or_else(
            || {
                let clean_path = path
                    .trim_matches('/')
                    .replace(['/', '{', '}'], "_")
                    .replace(|c: char| !c.is_alphanumeric(), "");
                format!("{}{}", http_method, self.to_pascal_case(&clean_path))
            },
            |id| self.to_pascal_case(id),
        )
    }

    fn generate_parameters_message(
        &mut self,
        message_name: &str,
        parameters: Vec<&Parameter>,
        definitions: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<String, ConverterError> {
        if self.messages.contains_key(message_name) {
            return Ok(self.messages[message_name].clone());
        }

        let mut message = format!("message {} {{\n", message_name);
        let mut field_number = 1;

        for param in parameters {
            // Добавляем описание параметра
            if let Some(desc) = &param.description {
                message.push_str(&format!("  /* {} */\n", desc));
            }

            // Определяем тип параметра
            let proto_type = if let Some(schema_ref) = &param.schema {
                self.schema_ref_to_type(schema_ref, definitions, components)?
            } else {
                // Если схема не указана, используем тип из поля type_
                match param.type_.as_deref() {
                    Some("integer") => "int64".to_string(),
                    Some("number") => "double".to_string(),
                    Some("boolean") => "bool".to_string(),
                    _ => "string".to_string(),
                }
            };

            // Определяем, обязательный ли параметр
            let rule = if param.required.unwrap_or(false) {
                ""
            } else {
                "optional "
            };
            let field_name = self.sanitize_field_name(&param.name);

            message.push_str(&format!(
                "  {}{} {} = {};\n",
                rule, proto_type, field_name, field_number
            ));
            field_number += 1;
        }

        message.push_str("}\n\n");
        self.messages
            .insert(message_name.to_string(), message.clone());
        Ok(message)
    }

    fn generate_body_message(
        &mut self,
        message_name: &str,
        request_body: &RequestBody,
        definitions: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<String, ConverterError> {
        if self.messages.contains_key(message_name) {
            return Ok(self.messages[message_name].clone());
        }

        let mut message = String::new();

        // Добавляем описание
        if let Some(description) = &request_body.description {
            message.push_str(&format!("/* {} */\n", description));
        }

        message.push_str(&format!("message {} {{\n", message_name));

        // Обрабатываем содержимое body
        if let Some((content_type, media_type)) = request_body.content.iter().next() {
            if let Some(schema_ref) = &media_type.schema {
                let proto_type = self.schema_ref_to_type(schema_ref, definitions, components)?;

                // Для сложных типов создаем отдельные сообщения
                if proto_type.contains("map<") || proto_type == "google.protobuf.Struct" {
                    message.push_str(&format!(
                        "  {} data = 1 [json_name = \"{}\"];\n",
                        proto_type, content_type
                    ));
                } else {
                    message.push_str(&format!(
                        "  {} data = 1; // Content-Type: {}\n",
                        proto_type, content_type
                    ));
                }
            } else {
                // Если схема не указана, используем строку
                message.push_str("  string data = 1;\n");
            }
        } else {
            message.push_str("  // No content schema defined\n");
        }

        message.push_str("}\n\n");
        self.messages
            .insert(message_name.to_string(), message.clone());
        Ok(message)
    }

    fn sanitize_field_name(&self, name: &str) -> String {
        let mut sanitized = String::with_capacity(name.len());
        let mut prev_was_underscore = false;

        for c in name.chars() {
            match c {
                'a'..='z' | 'A'..='Z' | '0'..='9' => {
                    sanitized.push(c);
                    prev_was_underscore = false;
                }
                _ => {
                    if !prev_was_underscore && !sanitized.is_empty() {
                        sanitized.push('_');
                        prev_was_underscore = true;
                    }
                }
            }
        }

        // Удаляем завершающий underscore если есть
        if sanitized.ends_with('_') {
            sanitized.pop();
        }

        // Имена не могут начинаться с цифры
        if sanitized
            .chars()
            .next()
            .map(|c| c.is_ascii_digit())
            .unwrap_or(false)
        {
            sanitized = format!("_{}", sanitized);
        }

        // Имя не может быть пустым
        if sanitized.is_empty() {
            sanitized = "field".to_string();
        }

        sanitized
    }

    fn to_pascal_case(&self, s: &str) -> String {
        s.split(|c: char| !c.is_alphanumeric())
            .filter(|part| !part.is_empty())
            .map(|part| {
                let mut c = part.chars();
                match c.next() {
                    None => String::new(),
                    Some(f) => f.to_uppercase().chain(c).collect(),
                }
            })
            .collect()
    }

    fn generate_service_proto(
        &mut self,
        proto: &mut String,
        service_name: &str,
        methods: &[(String, String, &Operation)],
        definitions: &HashMap<String, Schema>,
        components: Option<&Components>,
    ) -> Result<(), ConverterError> {
        // 1. Генерируем все необходимые сообщения для сервиса
        let mut messages_section = String::new();
        let mut rpc_methods = String::new();

        for (path, http_method, operation) in methods {
            let method_name = self.generate_method_name(path, http_method, operation);

            // Генерируем документацию метода
            let mut method_docs = String::new();
            if let Some(summary) = &operation.summary {
                method_docs.push_str(&format!("  // {}\n", summary));
            }
            if let Some(description) = &operation.description {
                for line in description.lines() {
                    method_docs.push_str(&format!("  // {}\n", line.trim()));
                }
            }
            if operation.deprecated.unwrap_or(false) {
                method_docs.push_str("  // Deprecated\n");
            }

            // Генерируем типы запросов
            let (request_type, request_messages) = self.generate_request_message(
                service_name,
                &method_name,
                operation,
                definitions,
                components,
            )?;

            // Добавляем сообщения в секцию messages
            for message in request_messages {
                messages_section.push_str(&message);
            }

            // Генерируем тип ответа
            let response_type = self.generate_response_type(operation, definitions, components)?;

            // Формируем RPC метод
            rpc_methods.push_str(&method_docs);
            rpc_methods.push_str(&format!(
                "  rpc {}({}) returns ({});\n\n",
                method_name, request_type, response_type
            ));
        }

        // 2. Добавляем раздел с сообщениями перед сервисом
        if !messages_section.is_empty() {
            proto.push_str(&format!("// Messages for {}Service\n", service_name));
            proto.push_str(&messages_section);
        }

        // 3. Генерируем сам сервис
        proto.push_str(&format!("service {}Service {{\n", service_name));
        proto.push_str(&rpc_methods);
        proto.push_str("}\n\n");

        Ok(())
    }
}

fn main() -> Result<(), ConverterError> {
    let input_path = "swagger.json";
    let output_path = "api.proto";

    let mut converter = ProtoConverter::new();
    converter.convert(input_path, output_path)?;

    println!("Successfully converted {} to {}", input_path, output_path);
    Ok(())
}
